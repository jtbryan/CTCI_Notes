# Data Structure Notes

## Arrays/Strings

## Linked Lists

## Stacks & Queues

## Trees

## Graphs

A graph data structure **(V, E)** consists of the following:
* Vertices **(V)**: A collection of nodes or vertices
* Edges **(E)**: A collection of paths or edges

Fundamental algorithms for graphs include the following:

### **BFS**
This is a graph traversal algorithm that traverses the graph from the nearest node (root node) and explores all unexplored (neighboring) nodes by level. You can consider any node in the graph as a root node when using BFS for traversal

Every vertex of a graph is put into the following categories:
* Visited
* Non-visited

This specific algorithm uses the **Queue** data structure to find the shortest path in a given graph. 

Below is an example of how BFS is performed:

```python
def bfs(graph, root):
    visited = set()
    # If not off limits, we could use collections.deque instead which is faster
    queue = []

    visited.add(root)
    queue.append(root)

    while queue:
        # If this was deqeue, we would use popLeft()
        # a list popping the first is O(n) whereas deque is O(1)
        vertex = queue.pop(0)

        # Perform opetation at this node

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
bfs(graph, 0)
```

### **DFS**
The depth-first search algorithm starts the traversal from the initial node of a given graph and goes deeper until we find the target node or the leaf node (with no children). DFS then backtracks from the leaf node towards the most recent node to explore it.

This specific algorithm uses the **Stack** data structure to find the shortest path in a given graph. 

Below is an example of how DFS is performed recursively:

```python
def recursiveDfs(graph, node, visited=None):
    if visited = None:
        visited = set()
    if node not in visited:
        # do stuff
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
dfs(graph, 0)
```

And this is how it can be perfroemd iteratively (essentially similar to bfs but instead we use the stack):

```python
def iterativeDfs(graph, node, visited=None):
    if visited = None:
        visited = set()
    stack = []

    visited.add(root)
    stack.append(root)

    while stack:
        vertex = stack.pop()

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                stack.append(neighbor)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
dfs(graph, 0)
```

## Maps/Dictionaries

### Time Complexity

* **Insert**
    * Average: **O(1)**
    * Worst: **O(n)**

* **Get**
    * Average: **O(1)**
    * Worst: **O(n)**

* **Delete**
    * Average: **O(1)**
    * Worst: **O(n)**
### Example

```python
mapping = dict()

# Update/Set 
mapping["key"] = mapping.get("key", 0) + 1

# Loop
for key in mapping:
    mapping[key] = ?

# Delete
mapping.pop('key', None)

# OR

del mapping['key'] # if it definitely exists

# Creating a dynamic map
numbers = (1, 2, 3, 4)
mapping = map(lambda x: x + x, numbers)
```
## Heaps

