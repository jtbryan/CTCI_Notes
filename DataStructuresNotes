# Data Structure Notes

## Arrays/Strings

## Linked Lists

## Stacks & Queues

## Trees

A tree is a special kind of graph data structure that has a `root` node and a `left` and `right` node. I.e.:

```python
class TreeNode:
    self.val = None
    self.right = None
    self.left = None
```

Here are a few ways to traverse trees:

* **Inorder** traversal
```python
...
go_left(root.left)
process_current_root()
go_right(root.right)
...
```
* **Preorder** traversal
```python
...
process_current_root()
go_left(root.left)
go_right(root.right)
...
```
* **Postorder** traversal
```python
...
go_left(root.left)
go_right(root.right)
process_current_root()
...
```
* **Level-order** traversal
```python
...
node = queue.pop(0)
process_current_root(node)
go_left(root.left)
go_right(root.right)
...
```
    
This method is very similar to Preorder traversal, but in this case, if we want to achieve an iterative approach, we can use a queue similar to `BFS`. Instead of graph neighbors, we only care about `node.left` and `node.right` though if they are valid. In this case, we don't need a `visited` set though because we know the binary tree is directed. An example of this can be seen here:

```python
def iterativeLevelOrder(root: TreeNode) -> List[List[int]]:
    if not root:
        return []
    
    queue = [root]
    result = []
    
    while queue:
        level_size = len(queue)
        level_vals = []
        for i in range(level_size):
            node = queue.pop(0)
            level_vals.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
                
        result.append(level_vals)
        
    return result
```

a recursive version of this would be the following:

```python
def recursiveLevelOrder(root: TreeNode) -> List[List[int]]:
    result = []
    def helper(node: TreeNode, level: int):
        if not node:
            return
        if len(result) == level:
            result.append([])
        result[level].append(node.val)
        helper(node.left, level+1)
        helper(node.right, level+1)
    
    helper(root, 0)
    return result
```

## Graphs

A graph data structure **(V, E)** consists of the following:
* Vertices **(V)**: A collection of nodes or vertices
* Edges **(E)**: A collection of paths or edges

Fundamental algorithms for graphs include the following:

### **BFS**
This is a graph traversal algorithm that traverses the graph from the nearest node (root node) and explores all unexplored (neighboring) nodes by level. You can consider any node in the graph as a root node when using BFS for traversal

Every vertex of a graph is put into the following categories:
* Visited
* Non-visited

This specific algorithm uses the **Queue** data structure to find the shortest path in a given graph. 

Below is an example of how BFS is performed:

```python
def bfs(graph, root):
    visited = set()
    # If not off limits, we could use collections.deque instead which is faster
    queue = []

    visited.add(root)
    queue.append(root)

    while queue:
        # If this was deqeue, we would use popleft()
        # a list popping the first is O(n) whereas deque is O(1)
        vertex = queue.pop(0)

        # Perform opetation at this node

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
bfs(graph, 0)
```

### **DFS**
The depth-first search algorithm starts the traversal from the initial node of a given graph and goes deeper until we find the target node or the leaf node (with no children). DFS then backtracks from the leaf node towards the most recent node to explore it.

This specific algorithm uses the **Stack** data structure to find the shortest path in a given graph. 

Below is an example of how DFS is performed recursively:

```python
def recursiveDfs(graph, node, visited=None):
    if visited = None:
        visited = set()
    if node not in visited:
        # do stuff
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
dfs(graph, 0)
```

And this is how it can be perfroemd iteratively (essentially similar to bfs but instead we use the stack):

```python
def iterativeDfs(graph, node, visited=None):
    if visited = None:
        visited = set()
    stack = []

    visited.add(root)
    stack.append(root)

    while stack:
        vertex = stack.pop()

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                stack.append(neighbor)

graph = {0: [1, 2], 1: [2], 2: [3], 3: [1, 2]}
dfs(graph, 0)
```

### Example problem using DFS

Source: https://leetcode.com/problems/number-of-islands/

Prompt: Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        rows = len(grid)
        cols = len(grid[0])

        if rows == 0 or cols == 0:
            return 0
        
        def dfs(curRow, curCol):
            if curRow < 0 or curRow == rows or curCol < 0 or curCol == cols:
                return

            if grid[curRow][curCol] == "1":
                grid[curRow][curCol] = "V"
            
            else:
                return

            dfs(curRow-1, curCol)
            dfs(curRow+1, curCol)
            dfs(curRow, curCol-1)
            dfs(curRow, curCol+1)

        count = 0

        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == "1":
                    count += 1
                    dfs(row, col)

        return count
```

## Maps/Dictionaries

### Time Complexity

* **Insert**
    * Average: **O(1)**
    * Worst: **O(n)**

* **Get**
    * Average: **O(1)**
    * Worst: **O(n)**

* **Delete**
    * Average: **O(1)**
    * Worst: **O(n)**
### Example

```python
mapping = dict()

# Update/Set 
mapping["key"] = mapping.get("key", 0) + 1

# Loop
for key in mapping:
    mapping[key] = ?

# Delete
mapping.pop('key', None)

# OR

del mapping['key'] # if it definitely exists

# Creating a dynamic map
numbers = (1, 2, 3, 4)
mapping = map(lambda x: x + x, numbers)
```
## Heaps

